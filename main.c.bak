#include <assert.h>
#include <stdio.h>
#include <readline/readline.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
// #include "deque_tt.h"
#include "libft/dsa/dyn_str.h"
#include "libft/utils/utils.h"
#include "minishell.h"
#include "libft/libft.h"

bool is_space(char c)
{
	if (c == ' ' || c == '\t')
		return (true);
	return (false);
}

bool is_special_char(char c) {
    char* specials = ";$'\"<>|&()\n";
	if (ft_strchr(specials, c) || is_space(c)){
		return true;
	}
    return false;
}

int parse_squoted_word(t_deque_tt* tokens, char** str) {
    assert(**str == '\'');
    (*str)++;
    char* start = *str;
	char prev = 0;
    while (**str && (**str != '\'' || prev == '\\'))
	{
        (*str)++;
	}
	deque_tt_push_end(tokens,
		(t_token){.start = start, .len = *str - start, .tt = TT_WORD, .quoted = 1});
    if (**str != '\'')
		return (1);
    (*str)++;
	return (0);
}


int parse_dquoted_word(t_deque_tt* tokens, char** str) {
    assert(**str == '"');
    (*str)++;
    char* start = *str;
	char prev = 0;
    while (**str && (**str != '"' || prev == '\\')) {
		prev = **str;
		(*str)++;
    }
	deque_tt_push_end(tokens,
        (t_token){.start = start, .len = *str - start, .tt = TT_WORD});
    if (**str != '"')
		return (1);
    (*str)++;
	return (0);
}

void parse_word(t_deque_tt* tokens, char** str) {
    char* start = *str;
    assert(!is_special_char(**str));
    while (**str && !is_special_char(**str))
	{
        (*str)++;
	}
	deque_tt_push_end(tokens,
        (t_token){.start = start, .len = *str - start, .tt = TT_WORD});
}

typedef struct op_map_s {
	char *str;
	t_tt t;
} op_map_t;

int longest_matching_str(op_map_t *needles, char* haystack) {
    int max_idx = -1;
    int max = -1;
    for (int i = 0; needles[i].str; i++) {
        if ((int)strlen(needles[i].str) > max &&
            strncmp(needles[i].str, haystack, strlen(needles[i].str)) == 0) {
            max_idx = i;
            max = strlen(needles[i].str);
        }
    }
    return (max_idx);
}

void parse_op(t_deque_tt* tokens, char** str) {
    op_map_t operators[] = {
		(op_map_t){"|", TT_PIPE},
		(op_map_t){"=", TT_EQ},
		(op_map_t){"<<", TT_HEREDOC},
		(op_map_t){">>", TT_APPEND},
		(op_map_t){"(", TT_BRACE_LEFT},
		(op_map_t){")", TT_BRACE_RIGHT},
		(op_map_t){">", TT_REDIRECT_RIGHT},
		(op_map_t){"<", TT_REDIRECT_LEFT},
		(op_map_t){"&&", TT_AND},
		(op_map_t){"||", TT_OR},
		(op_map_t){";", TT_SEMICOLON},
		(op_map_t){0, TT_END},
    };

    char* start = *str;
    int op_idx = longest_matching_str(operators, *str);
    fflush(stdout);
    assert(op_idx != -1);
    *str += strlen(operators[op_idx].str);
	deque_tt_push_end(tokens,
        (t_token){.start = start, .len = *str - start, .tt = operators[op_idx].t});
}

void parse_sep(t_deque_tt* tokens, char** str) {
    char* start = *str;
    assert(is_space(**str));
    while (is_space(**str))
	{
        (*str)++;
	}
	deque_tt_push_end(tokens,
        (t_token){.start = start, .len = *str - start, .tt = TT_SEP});
}

void parse_newline(t_deque_tt *tokens, char **str)
{
	assert(**str == '\n');
	(*str)++;
	deque_tt_push_end(tokens,
        (t_token){.start = *str - 1, .len = 1, .tt = TT_NEWLINE});
}

// If returns 0, it finished properly, if it returns a ptr, make a prompt with that str
char *tokenizer(char* str, t_deque_tt *ret) {
    while (*str) {
        if (*str == '\'') {
            if (parse_squoted_word(ret, &str))
				return ("squote> ");
        } else if (*str == '"') {
            if (parse_dquoted_word(ret, &str))
				return ("dquote> ");
        } else if (*str == '\n') {
			parse_newline(ret, &str);
        } else if (!is_special_char(*str)) {
            parse_word(ret, &str);
        } else if (*str == ' ' || *str == '\t') {
            parse_sep(ret, &str);
        } else if (*str == '$') {
            parse_env_var(ret, &str);
        } else {
            parse_op(ret, &str);
        }
    }
    return (0);
}

char* tt_to_str(t_tt tt) {
    switch (tt) {
        case TT_END:
			return ("TT_END");
		case TT_ENVVAR:
			return ("TT_ENVVAR");
		case TT_SEP:
			return ("TT_SEP");
		case TT_WORD:
			return ("TT_WORD");
		case TT_REDIRECT_LEFT:
			return ("TT_REDIRECT_LEFT");
		case TT_REDIRECT_RIGHT:
			return ("TT_REDIRECT_RIGHT");
		case TT_APPEND:
			return ("TT_APPEND");
		case TT_PIPE:
			return ("TT_PIPE");
		case TT_BRACE_LEFT:
			return ("TT_BRACE_LEFT");
		case TT_BRACE_RIGHT:
			return ("TT_BRACE_RIGHT");
		case TT_OR:
			return ("TT_OR");
		case TT_AND:
			return ("TT_AND");
		case TT_SEMICOLON:
			return ("TT_SEMICOLON");
		case TT_NEWLINE:
			return ("TT_NEWLINE");
		case TT_EQ:
			return ("TT_EQ");
		case TT_HEREDOC:
			return ("TT_HEREDOC");
		case TT_NONE:
			assert(false);
	}
	return 0;
}

void print_tokens(t_deque_tt tokens) {
	t_token curr;
	for (int i = 0; i < tokens.len; i++) {
		curr = *deque_tt_idx(&tokens, i);
        printf("%s: >%.*s<\n", tt_to_str(curr.tt), curr.len, curr.start);
	}
}

typedef struct s_exe_cmd {
	char *exe_name;
	char **params;
} t_exe_cmd;

typedef struct s_cmd {
	t_exe_cmd *normal_cmd;
	void *binary_expr;
	bool is_normal_cmd;
} t_cmd;

typedef struct s_braced_expr {
	int piped_commands;
} t_braced_expr;

typedef struct s_binary_expr {
	t_braced_expr *left;
	struct s_binary_expr *right;
	int op;
}	t_binary_expr;


void replace_escaped_newlines (t_dyn_str *input)
{
	t_dyn_str out;
	int	i;
	bool	backslash;

	dyn_str_init(&out);
	i = -1;
	backslash = false;
	while (input->buff[++i])
	{
		if (input->buff[i] == '\\')
		{
			backslash = true;
			continue;
		}
		if (backslash)
		{
			if (input->buff[i] != '\n')
			{
				dyn_str_push(&out, '\\');
				dyn_str_push(&out, input->buff[i]);
			}
			backslash = false;
			continue;
		}
		dyn_str_push(&out, input->buff[i]);
	}
	free(input->buff);
	*input = out;
}

int main() {
	t_state	state;
	char *line;
	char *prompt;
	t_deque_tt	tt;

	deque_tt_init(&tt, 100);
	dyn_str_init(&state.prompt);

	prompt = "prompt> ";
	while (prompt) {
		line = readline(prompt);
		if (line == 0)
			continue;
		dyn_str_pushstr(&state.prompt, line);
		dyn_str_push(&state.prompt, '\n');
		free(line);
		if (state.prompt.len <= 1)
			continue;
		char c = dyn_str_idx(&state.prompt, state.prompt.len - 2);
		if (c == '\\')
			continue;
		replace_escaped_newlines(&state.prompt);
		prompt = tokenizer(state.prompt.buff, &tt);
		if (prompt)
			tt.len = 0;
	}
    print_tokens(tt);
	free(state.prompt.buff);
    free(tt.buff);
}

